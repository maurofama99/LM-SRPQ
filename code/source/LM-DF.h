#pragma once
#include<iostream>
#include<fstream>
#include<map>
#include<unordered_map>
#include<unordered_set>
#include<string>
#include <queue>
#include<stack>
#include <chrono>
#include "forest_struct.h"
#include "automaton.h"
#define merge_long_long(s, d) (((unsigned long long)s<<32)|d)
using namespace std;


// this is the algorithm fo LM-SROQ



class LM_DF
{
public:
	streaming_graph* g; // pointer to the streaming graph
	automaton* aut;// pointer to the DFA generated by the regular expression
	map<unsigned int, double> aut_scores; // this map stores the depth we estimated for each state in the DFA
	unordered_map<unsigned long long, RPQ_tree*> forests; // unordered map that maps each vertex ID-state pair to the spanning tree rooted at it. the vertex ID and the state is merged into an Unsigned long long 
	unordered_map<unsigned long long, RPQ_tree*> DF_forest; // forests of depdency graph trees (DF trees), here we still use the structure of RPQ_tree*, but in fact the DF tree is simpler thant RPQ tree, with no structes landmark set. We use RPQ_tree* just for convenience 
	map<unsigned int, tree_info_index*> v2t_index; // Maps each state to a tree_info_index, reverse index that maps a graph vertex to the normal trees that contains it.
	map<unsigned int, tree_info_index*> v2d_index;// which is a reverse index that maps a landmark to the dependency graph tree that contains it. Not that we only build dependency graph trees for initial state node.
	map<unsigned int, lm_info_index*> v2l_index; // Maps each state to a lm_info_index, reverse index that maps a graph vertex to the LM trees that contains it.
	unordered_map<unsigned long long, unsigned int> result_pairs;
	unordered_map<unsigned long long, unsigned int> result_lm;
	unordered_set<unsigned long long> landmarks; // set of landmarks, vertex ID and states are merged.
	bool record_path;

	LM_DF(streaming_graph* g_, automaton* automaton)
	{
		g = g_;
		aut = automaton;
		record_path = true;
	}
	~LM_DF()
	{
		unordered_map<unsigned long long, RPQ_tree*>::iterator it;
		for (it = forests.begin(); it != forests.end(); it++)
			delete it->second;
		forests.clear();
		map<unsigned int, tree_info_index*>::iterator it2;
		for (it2 = v2t_index.begin(); it2 != v2t_index.end(); it2++)
			delete it2->second;
		for (it2 = v2d_index.begin(); it2 != v2d_index.end(); it2++)
			delete it2->second;
		map<unsigned int, lm_info_index*>::iterator it3;
		for (it3 = v2l_index.begin(); it3 != v2l_index.end(); it3++)
			delete it3->second;
		v2t_index.clear();
		v2l_index.clear();
		v2d_index.clear();
		result_pairs.clear();
		landmarks.clear();
		aut_scores.clear();
	}

	void update_result(unordered_map<unsigned int, unsigned int>& updated_nodes, unsigned int root_ID, unsigned int lm_time = MAX_INT)
		// first of updated nodes are vertex ID, second are path timestamps, root_ID can reach these vertices with a qualified regular path.
			// when lm time is set, updated_nodes store path timestamps from a landmark to the vertices, lm time is the path timestamp from root to the landmark, we need to first merge these two parts and then update the result set. 
	{
		for (unordered_map<unsigned int, unsigned int>::iterator it = updated_nodes.begin(); it != updated_nodes.end(); it++)
		{
			unsigned int dst = it->first;
			unsigned int time = min(it->second, lm_time);
			if (dst == root_ID)
				continue;
			unsigned long long result_pair = (((unsigned long long)root_ID << 32) | dst);
			if (result_pairs.find(result_pair) != result_pairs.end())
				result_pairs[result_pair] = max(result_pairs[result_pair], time);
			else
				result_pairs[result_pair] = time;
		}
	}

	void update_result(vector<pair<unsigned int, unsigned int> >& updated_nodes, unsigned int root_ID, unsigned int lm_time = MAX_INT)
	{
		for (int i = 0; i < updated_nodes.size(); i++)
		{
			unsigned int dst = updated_nodes[i].first;
			unsigned int time = min(updated_nodes[i].second, lm_time);
			if (dst == root_ID)
				continue;
			unsigned long long result_pair = (((unsigned long long)root_ID << 32) | dst);
			if (result_pairs.find(result_pair) != result_pairs.end())
				result_pairs[result_pair] = max(result_pairs[result_pair], time);
			else
				result_pairs[result_pair] = time;
		}
	}


	void add_index(RPQ_tree* tree_pt, unsigned int v, unsigned int state, unsigned int root_ID) // modify the reverse index when a node is added into a normal tree;
	{
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter == v2t_index.end())
			v2t_index[state] = new tree_info_index;
		v2t_index[state]->add_node(tree_pt, v, root_ID);
	}

	void add_lm_index(RPQ_tree* tree_pt, unsigned int v, unsigned int state, unsigned int root_ID, unsigned int root_state) // modify the reverse index when a node is added into an LM tree;
	{
		map<unsigned int, lm_info_index*>::iterator iter = v2l_index.find(state);
		if (iter == v2l_index.end())
			v2l_index[state] = new lm_info_index;
		v2l_index[state]->add_node(tree_pt, v, root_ID, root_state);
	}

	void add_df_index(RPQ_tree* tree_pt, unsigned int v, unsigned int state, unsigned int root_ID) // modify the reverse index when a landmark is added into a dependency graph tree;
	{
		map<unsigned int, tree_info_index*>::iterator iter = v2d_index.find(state);
		if (iter == v2d_index.end())
			v2d_index[state] = new tree_info_index;
		v2d_index[state]->add_node(tree_pt, v, root_ID);
	}

	tree_node* add_node(RPQ_tree* tree_pt, unsigned int v, unsigned int state, unsigned int root_ID, tree_node* parent, unsigned int timestamp, unsigned int edge_time, bool lm = false) // add a node to a normal tree, bool lm indicating if this node is a landmark.
	{
		add_index(tree_pt, v, state, root_ID);
		tree_node* tmp = tree_pt->add_node(v, state, parent, timestamp, edge_time);
		tmp->lm = lm;
		return tmp;
	}


	tree_node* add_lm_node(RPQ_tree* lm_tree, unsigned int v, unsigned int state, unsigned int root_ID, unsigned int root_state,
		tree_node* parent, unsigned int timestamp, unsigned int edge_time, bool lm = false) // add a node to the LM tree .
	{
		add_lm_index(lm_tree, v, state, root_ID, root_state);
		tree_node* tmp = lm_tree->add_node(v, state, parent, timestamp, edge_time);
		tmp->lm = lm;
		return tmp;
	}

	tree_node* add_df_node(RPQ_tree* tree_pt, unsigned int v, unsigned int state, unsigned int root_ID, tree_node* parent, unsigned int timestamp, unsigned int edge_time) // add a node to a normal tree, bool lm indicating if this node is a landmark.
	{
		add_df_index(tree_pt, v, state, root_ID);
		tree_node* tmp = tree_pt->add_node(v, state, parent, timestamp, edge_time);
		return tmp;
	}




	void delete_index(unsigned int v, unsigned int state, unsigned int root)// modify the reverse index when a node is deleted from a normal tree;
	{
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			iter->second->delete_node(v, root);
			if (iter->second->tree_index.empty())
				v2t_index.erase(iter);
		}
	}

	void delete_lm_index(unsigned int v, unsigned int state, unsigned int root, unsigned int root_state) // modify the reverse index when a node is deleted from an LM tree;
	{
		map<unsigned int, lm_info_index*>::iterator iter = v2l_index.find(state);
		if (iter != v2l_index.end())
		{
			iter->second->delete_node(v, root, root_state);
			if (iter->second->tree_index.empty())
				v2l_index.erase(iter);
		}
	}

	void delete_df_index(unsigned int v, unsigned int state, unsigned int root)// modify the reverse index when a node is deleted from a normal tree;
	{
		map<unsigned int, tree_info_index*>::iterator iter = v2d_index.find(state);
		if (iter != v2d_index.end())
		{
			iter->second->delete_node(v, root);
			if (iter->second->tree_index.empty())
				v2d_index.erase(iter);
		}
	}

	void get_DG_successor(unsigned long long tree_info, unordered_map<unsigned long long, unsigned int>& successors)
	{
		if (forests.find(tree_info) != forests.end())
		{
			RPQ_tree* tree = forests[tree_info];
			for (unordered_map<unsigned long long, unsigned int>::iterator iter = tree->timed_landmarks.begin(); iter != tree->timed_landmarks.end(); iter++)
			{
				successors[iter->first] = iter->second;
			}
		}
	}

	void batch_DF_expand(vector<tree_node*>& expand_node, RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_nodes)
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned int root_info = merge_long_long(root_ID, root_state);
		priority_queue<tree_node*, vector<tree_node*>, time_compare> q;
		for (int i = 0; i < expand_node.size(); i++)
			q.push(expand_node[i]);
		while (!q.empty())
		{
			tree_node* tmp = q.top();
			q.pop();
			unsigned long long info = merge_long_long(tmp->node_ID, tmp->state);
			if (updated_nodes.find(info) == updated_nodes.end() || updated_nodes[info] < tmp->timestamp)
				updated_nodes[info] = tmp->timestamp;
			else
				continue;
			unordered_map<unsigned long long, unsigned int> successors;
			get_DG_successor(info, successors);
			for (unordered_map<unsigned long long, unsigned int>::iterator iter2 = successors.begin(); iter2 != successors.end(); iter2++)
			{
				unsigned int dst_id = (iter2->first >> 32);
				unsigned int dst_state = (iter2->first & 0xFFFFFFFF);
				unsigned int time = min(iter2->second, tmp->timestamp);

				if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(dst_id) == tree_pt->node_map[dst_state]->index.end())
				{
					tree_node* new_node = add_df_node(tree_pt, dst_id, dst_state, root_ID, tmp, min(tmp->timestamp, iter2->second), iter2->second);
					q.push(new_node);
				}
				else
				{
					tree_node* dst_pt = tree_pt->node_map[dst_state]->index[dst_id];
					if (dst_pt->timestamp < time) // if the node exists but has a smaller timestamp
					{
						if (dst_pt->parent != tmp)
							tree_pt->substitute_parent(tmp, dst_pt);
						dst_pt->timestamp = time;
						dst_pt->edge_timestamp = iter2->second;
						q.push(dst_pt);
					}

				}

			}

		}

	}

	void DF_expand(tree_node* expand_node, RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_nodes)
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned int root_info = merge_long_long(root_ID, root_state);
		priority_queue<tree_node*, vector<tree_node*>, time_compare> q;
		q.push(expand_node);
		while (!q.empty())
			{
				tree_node* tmp = q.top();
				q.pop();
				unsigned long long info = merge_long_long(tmp->node_ID, tmp->state);
				if (updated_nodes.find(info) == updated_nodes.end() || updated_nodes[info] < tmp->timestamp)
					updated_nodes[info] = tmp->timestamp;
				else
					continue;
				unordered_map<unsigned long long, unsigned int> successors;
				get_DG_successor(info, successors);
				for (unordered_map<unsigned long long, unsigned int>::iterator iter2 = successors.begin(); iter2 != successors.end(); iter2++)
				{
					unsigned int dst_id = (iter2->first >> 32);
					unsigned int dst_state = (iter2->first & 0xFFFFFFFF);
					unsigned int time = min(iter2->second, tmp->timestamp);

					if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(dst_id) == tree_pt->node_map[dst_state]->index.end())
					{
						tree_node* new_node = add_df_node(tree_pt, dst_id, dst_state, root_ID, tmp, min(tmp->timestamp, iter2->second), iter2->second);
						q.push(new_node);
					}
					else
					{
						tree_node* dst_pt = tree_pt->node_map[dst_state]->index[dst_id];
						if (dst_pt->timestamp < time) // if the node exists but has a smaller timestamp
						{
							if (dst_pt->parent != tmp)
								tree_pt->substitute_parent(tmp, dst_pt);
							dst_pt->timestamp = time;
							dst_pt->edge_timestamp = iter2->second;
							q.push(dst_pt);
						}

					}

				}

			}

	}
	
	void expand(tree_node* expand_node, RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_de, unordered_map<unsigned int, unsigned int>& updated_nodes, bool if_lm_tree = false) // expand a delta tree, and record the newly updated dependency edges.
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned int root_info = merge_long_long(root_ID, root_state);
		priority_queue<tree_node*, vector<tree_node*>, time_compare> q;
		q.push(expand_node);
		while (!q.empty())
		{
			tree_node* tmp = q.top();
			q.pop();
			unsigned long long info = merge_long_long(tmp->node_ID, tmp->state);
			if (landmarks.find(info) != landmarks.end())
			{
				tmp->lm = true;
				tree_pt->add_timed_lm(info, tmp->timestamp);
				updated_de[info] = tmp->timestamp;
				continue;
			}
			if (aut->final_state.find(tmp->state) != aut->final_state.end()){
				if(updated_nodes.find(tmp->node_ID)==updated_nodes.end())
					updated_nodes[tmp->node_ID] = tmp->timestamp;
				else
					updated_nodes[tmp->node_ID] = max(updated_nodes[tmp->node_ID], tmp->timestamp);
			}


			map<int, int> aut_edge;
			aut->get_all_suc(tmp->state, aut_edge); // get the edges acceptable to the src state
			vector<edge_info>sucs;
			g->get_timed_all_suc(tmp->node_ID, sucs); // get out edges of the src node
			for (int i = 0; i < sucs.size(); i++)
			{
				unsigned int successor = sucs[i].d;
				unsigned int label = sucs[i].label;
				unsigned int time = min(tmp->timestamp, sucs[i].timestamp);
				if (aut_edge.find(label) == aut_edge.end())
					continue;
				int dst_state = aut_edge[label];

				if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(successor) == tree_pt->node_map[dst_state]->index.end()) // if this node does not exist yet.
				{
					tree_node* new_node;
					if (if_lm_tree)
						new_node = add_lm_node(tree_pt, successor, dst_state, tree_pt->root->node_ID, tree_pt->root->state, tmp, time, sucs[i].timestamp);
					else
						new_node = add_node(tree_pt, successor, dst_state, tree_pt->root->node_ID, tmp, time, sucs[i].timestamp);
					q.push(new_node);
				}
				else
				{
					tree_node* dst_pt = tree_pt->node_map[dst_state]->index[successor];
					if (dst_pt->timestamp < time) // if the node exists but has a smaller timestamp
					{
						if (dst_pt->parent != tmp)
							tree_pt->substitute_parent(tmp, dst_pt);
						dst_pt->timestamp = time;
						dst_pt->edge_timestamp = sucs[i].timestamp;
						q.push(dst_pt);
					}
				}
			}
		}
	}



	void insert_edge_lm_tree(unsigned int s, unsigned int d, unsigned int label, int timestamp, unsigned int src_state, unsigned int dst_state, RPQ_tree* lm_tree, unordered_map<unsigned long long, unsigned int>& updated_de, unordered_map<unsigned int, unsigned int>& updated_nodes)
		// insert a new edge (s, src_state) (d, dst_state) with label and timestamp in an LM tree,
	{

		unsigned int root_ID = lm_tree->root->node_ID;
		unsigned int root_state = lm_tree->root->state;
		unsigned long long root_info = merge_long_long(root_ID, root_state);
		assert(lm_tree->node_map.find(src_state) != lm_tree->node_map.end());
		assert(lm_tree->node_map[src_state]->index.find(s) != lm_tree->node_map[src_state]->index.end());
		tree_node* src_pt = lm_tree->node_map[src_state]->index[s];
		unsigned long long src_info = merge_long_long(s, src_state);
		unsigned long long dst_info = merge_long_long(d, dst_state);

		tree_node* dst_pt = NULL;
		if (lm_tree->node_map.find(dst_state) == lm_tree->node_map.end() || lm_tree->node_map[dst_state]->index.find(d) == lm_tree->node_map[dst_state]->index.end()) // add the dst node if it is not in the tree yet.
			dst_pt = add_lm_node(lm_tree, d, dst_state, lm_tree->root->node_ID, lm_tree->root->state, src_pt, min(src_pt->timestamp, timestamp), timestamp);
		else { 
			dst_pt = lm_tree->node_map[dst_state]->index[d];
			if (dst_pt->timestamp < min(src_pt->timestamp, timestamp))
			{
				if (dst_pt->parent != src_pt)
					lm_tree->substitute_parent(src_pt, dst_pt);
				dst_pt->timestamp = min(src_pt->timestamp, timestamp);
				dst_pt->edge_timestamp = timestamp;
			}
			else
				return;
		}
		expand(dst_pt, lm_tree, updated_de, updated_nodes, true); // expand from the dst node
		if (root_state == 0)
			update_result(updated_nodes, root_ID);
	}



	void insert_edge_normal_tree(unsigned int s, unsigned int d, unsigned int label, int timestamp, unsigned int src_state, unsigned int dst_state,
		RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_de)
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned long long root_info = merge_long_long(root_ID, root_state);
		assert(tree_pt->node_map.find(src_state) != tree_pt->node_map.end());
		assert(tree_pt->node_map[src_state]->index.find(s) != tree_pt->node_map[src_state]->index.end());
		tree_node* src_pt = tree_pt->node_map[src_state]->index[s];
		unsigned long long src_info = merge_long_long(s, src_state);
		unsigned long long dst_info = merge_long_long(d, dst_state);
		unordered_map<unsigned int, unsigned int> updated_nodes;

		tree_node* dst_pt = NULL;
		if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(d) == tree_pt->node_map[dst_state]->index.end()) // add the dst node if it is not in the tree yet.
			dst_pt = add_node(tree_pt, d, dst_state, tree_pt->root->node_ID, src_pt, min(src_pt->timestamp, timestamp), timestamp);
		else { 
			dst_pt = tree_pt->node_map[dst_state]->index[d];
			if (dst_pt->timestamp < min(src_pt->timestamp, timestamp))
			{
				if (dst_pt->parent != src_pt)
					tree_pt->substitute_parent(src_pt, dst_pt);
				dst_pt->timestamp = min(src_pt->timestamp, timestamp);
				dst_pt->edge_timestamp = timestamp;
			}
			else
				return;
		}
		expand(dst_pt, tree_pt, updated_de, updated_nodes); // expand from the dst node
		update_result(updated_nodes, root_ID);
	}


	void insert_edge_df_tree(unsigned int s, unsigned int d, int timestamp, unsigned int src_state, unsigned int dst_state,
		RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_nodes)
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned long long root_info = merge_long_long(root_ID, root_state);
		assert(tree_pt->node_map.find(src_state) != tree_pt->node_map.end());
		assert(tree_pt->node_map[src_state]->index.find(s) != tree_pt->node_map[src_state]->index.end());
		tree_node* src_pt = tree_pt->node_map[src_state]->index[s];
		unsigned long long src_info = merge_long_long(s, src_state);
		unsigned long long dst_info = merge_long_long(d, dst_state);

		tree_node* dst_pt = NULL;
		if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(d) == tree_pt->node_map[dst_state]->index.end()) // add the dst node if it is not in the tree yet.
			dst_pt = add_df_node(tree_pt, d, dst_state, tree_pt->root->node_ID, src_pt, min(src_pt->timestamp, timestamp), timestamp);
		else { 
			dst_pt = tree_pt->node_map[dst_state]->index[d];
			if (dst_pt->timestamp < min(src_pt->timestamp, timestamp))
			{
				if (dst_pt->parent != src_pt)
					tree_pt->substitute_parent(src_pt, dst_pt);
				dst_pt->timestamp = min(src_pt->timestamp, timestamp);
				dst_pt->edge_timestamp = timestamp;
			}
			else
				return;
		}
		DF_expand(dst_pt, tree_pt, updated_nodes); // expand from the dst node
	}

	void batch_insert_edge_df_tree(unsigned int s, unsigned int src_state,	unordered_map<unsigned long long, unsigned int> &dst_info,
		RPQ_tree* tree_pt, unordered_map<unsigned long long, unsigned int>& updated_nodes)
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		unsigned long long root_info = merge_long_long(root_ID, root_state);
		assert(tree_pt->node_map.find(src_state) != tree_pt->node_map.end());
		assert(tree_pt->node_map[src_state]->index.find(s) != tree_pt->node_map[src_state]->index.end());
		tree_node* src_pt = tree_pt->node_map[src_state]->index[s];
		unsigned long long src_info = merge_long_long(s, src_state);

		vector<tree_node*> node2expand;
		for (unordered_map<unsigned long long, unsigned int>::iterator iter = dst_info.begin(); iter != dst_info.end(); iter++) {
			tree_node* dst_pt = NULL;
			unsigned int d = (iter->first >> 32);
			unsigned int dst_state = (iter->first & 0xFFFFFFFF);
			unsigned int timestamp = iter->second;
			if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(d) == tree_pt->node_map[dst_state]->index.end()) // add the dst node if it is not in the tree yet.
				dst_pt = add_df_node(tree_pt, d, dst_state, tree_pt->root->node_ID, src_pt, min(src_pt->timestamp, timestamp), timestamp);
			else { 
				dst_pt = tree_pt->node_map[dst_state]->index[d];
				if (dst_pt->timestamp < min(src_pt->timestamp, timestamp))
				{
					if (dst_pt->parent != src_pt)
						tree_pt->substitute_parent(src_pt, dst_pt);
					dst_pt->timestamp = min(src_pt->timestamp, timestamp);
					dst_pt->edge_timestamp = timestamp;
				}
				else
					continue;
			}
			node2expand.push_back(dst_pt);
		}
		batch_DF_expand(node2expand, tree_pt, updated_nodes); // expand from the dst node
	}


	void get_final_nodes(unsigned long long info, unordered_map<unsigned int, unsigned int>& final_nodes)
	{
		if (forests.find(info) != forests.end())
		{
			RPQ_tree* tree_pt = forests[info];
			for (map<unsigned int, tree_node_index*>::iterator iter = tree_pt->node_map.begin(); iter != tree_pt->node_map.end(); iter++)
			{
				if (aut->check_final_state(iter->first))
				{
					for (unordered_map<unsigned int, tree_node*>::iterator node_iter = iter->second->index.begin(); node_iter != iter->second->index.end(); node_iter++)
					{
						unsigned int time = node_iter->second->timestamp;
						if (final_nodes.find(node_iter->first) == final_nodes.end() || final_nodes[node_iter->first] < time)
							final_nodes[node_iter->first] = time;
					}
				}
			}
		}
	}

	void update_result_with_lm(unsigned long long info, unsigned int lm_time, unsigned int root)
	{

		if (forests.find(info) != forests.end())
		{
			RPQ_tree* tree_pt = forests[info];
			queue<tree_node*> q;
			q.push(tree_pt->root);
			while (!q.empty())
			{
				tree_node* tmp = q.front();
				q.pop();
				if (aut->check_final_state(tmp->state))
				{
					unsigned int id = tmp->node_ID;
					unsigned long long rp = merge_long_long(root, id);
					unsigned int time = min(lm_time, tmp->timestamp);
					if (result_pairs.find(rp) != result_pairs.end() && result_pairs[rp] >= time)
						continue;
					else
					{
						result_pairs[rp] = time;
						tree_node* child = tmp->child;
						while (child)
						{
							q.push(child);
							child = child->brother;
						}
					}
				}
				else
				{
					tree_node* child = tmp->child;
					while (child)
					{
						q.push(child);
						child = child->brother;
					}
				}
			}
		}
	}




	void insert_edge(unsigned int s, unsigned int d, unsigned int label, int timestamp) //  a new edge is inserted.
	{

		if (aut->acceptable_labels.find(label) == aut->acceptable_labels.end()) // we only insert the edge if the automaton can accept it, in this case the streaming graph is a layer graph containing necessray edges. 
			return;
		g->insert_edge(s, d, label, timestamp);
		if (aut->get_suc(0, label) != -1 && forests.find(merge_long_long(s, 0)) == forests.end()) // we need to build a new tree
		{
			RPQ_tree* new_tree = new RPQ_tree();
			if (landmarks.find(merge_long_long(s, 0)) == landmarks.end()) // a normal tree
				new_tree->root = add_node(new_tree, s, 0, s, NULL, MAX_INT, MAX_INT);
			else // an LM tree
				new_tree->root = add_lm_node(new_tree, s, 0, s, 0, NULL, MAX_INT, MAX_INT);
			forests[merge_long_long(s, 0)] = new_tree;
		}
		vector<pair<int, int> >vec;
		aut->get_possible_state(label, vec); // find all the state paris that can accept this label
		for (unsigned int i = 0; i < vec.size(); i++) {
			unsigned int src_state = vec[i].first;
			unsigned int dst_state = vec[i].second;
			if (landmarks.find(merge_long_long(s, src_state)) != landmarks.end()) // if (s, src_state) is a landmark
			{
				unordered_map<unsigned long long, unsigned int> updated_de;
				RPQ_tree* tree_pt = forests[merge_long_long(s, src_state)];
				unordered_map<unsigned int, unsigned int> updated_nodes;
				insert_edge_lm_tree(s, d, label, timestamp, src_state, dst_state, tree_pt, updated_de, updated_nodes); // update the lm tree, backtrack is also called, and the lm trees we find in backtrack and the updated reachable nodes of them are in lm_results.
				if (updated_de.empty() && updated_nodes.empty())
					continue;
				if (src_state == 0 && !updated_de.empty() && DF_forest.find(merge_long_long(s, src_state)) == DF_forest.end())
				{
					RPQ_tree* new_tree = new RPQ_tree();
					new_tree->root = add_df_node(new_tree, s, 0, s, NULL, MAX_INT, MAX_INT);
					DF_forest[merge_long_long(s, 0)] = new_tree;
				}
				map<unsigned int, tree_info_index*>::iterator index_iter = v2d_index.find(src_state);
				if (index_iter != v2d_index.end())
				{
					unordered_map<unsigned int, tree_info*>::iterator tree_iter = index_iter->second->tree_index.find(s);
					if (tree_iter != index_iter->second->tree_index.end()) {
						tree_info* tmp = tree_iter->second;
						while (tmp)
						{
							RPQ_tree* DF_tree = tmp->tree;
							unordered_map<unsigned long long, unsigned int> updated_lm;
							if (DF_tree->node_map.find(src_state) != DF_tree->node_map.end())
							{
								if (DF_tree->node_map[src_state]->index.find(s) != DF_tree->node_map[src_state]->index.end())
								{
									tree_node* src_DF_node = DF_tree->node_map[src_state]->index[s];
									unsigned int src_DF_time = src_DF_node->timestamp;
									if(DF_tree->root->node_ID!=s|| DF_tree->root->state!=src_state)
										update_result(updated_nodes, DF_tree->root->node_ID, src_DF_time);
									batch_insert_edge_df_tree(s, src_state, updated_de, DF_tree, updated_lm);
									for (unordered_map<unsigned long long, unsigned int>::iterator DF_suc_iter = updated_lm.begin(); DF_suc_iter != updated_lm.end(); DF_suc_iter++)
									{
										unordered_map<unsigned int, unsigned int> final_nodes;
										get_final_nodes(DF_suc_iter->first, final_nodes);
										update_result(final_nodes, DF_tree->root->node_ID, DF_suc_iter->second);
									}

								}
							}
							tmp = tmp->next;
						}
					}
				}

			}
			else {
				unordered_map<unsigned int, unordered_map<unsigned long long, unsigned int>> dependency_paths;
				map<unsigned int, lm_info_index*>::iterator index_iter = v2l_index.find(src_state); // if (s, src_state) is not a landmark, we need to first update all the LM trees contianing it, and backtrack from them.
				if (index_iter != v2l_index.end())
				{
					unordered_map<unsigned int, tree_info*>::iterator tree_iter = index_iter->second->tree_index.find(s);
					if (tree_iter != index_iter->second->tree_index.end()) {
						tree_info* tmp = tree_iter->second;
						while (tmp)
						{
							RPQ_tree* lm_tree = tmp->tree;
							unsigned int lm_root = lm_tree->root->node_ID;
							unsigned int lm_state = lm_tree->root->state;
							unordered_map<unsigned long long, unsigned int> updated_de;
							unordered_map<unsigned int, unsigned int> updated_nodes;
							insert_edge_lm_tree(s, d, label, timestamp, src_state, dst_state, tmp->tree, updated_de, updated_nodes);
							if (updated_de.empty() && updated_nodes.empty()) {
								tmp = tmp->next;
								continue;
							}
							if ( lm_state== 0 && !updated_de.empty() && DF_forest.find(merge_long_long(lm_root, lm_state)) == DF_forest.end())
							{
								RPQ_tree* new_tree = new RPQ_tree();
								new_tree->root = add_df_node(new_tree, lm_root, 0, lm_root, NULL, MAX_INT, MAX_INT);
								DF_forest[merge_long_long(lm_root, lm_state)] = new_tree;
							}
							map<unsigned int, tree_info_index*>::iterator DF_iter = v2d_index.find(lm_state);
							if (DF_iter != v2d_index.end())
							{
								unordered_map<unsigned int, tree_info*>::iterator DF_tree_iter = DF_iter->second->tree_index.find(lm_root);
								if (DF_tree_iter != DF_iter->second->tree_index.end()) {
									tree_info* DF_tmp = DF_tree_iter->second;
									while (DF_tmp)
									{
										RPQ_tree* DF_tree = DF_tmp->tree;
										if (DF_tree->node_map.find(lm_state) != DF_tree->node_map.end())
										{
											if (DF_tree->node_map[lm_state]->index.find(lm_root) != DF_tree->node_map[lm_state]->index.end())
											{
												tree_node* lm_DF_node = DF_tree->node_map[lm_state]->index[lm_root];
												unsigned int lm_DF_time = lm_DF_node->timestamp;
												if (DF_tree->root->node_ID != lm_root || DF_tree->root->state != lm_state)
													update_result(updated_nodes, DF_tree->root->node_ID, lm_DF_time);
												batch_insert_edge_df_tree(lm_root, lm_state, updated_de, DF_tree, dependency_paths[DF_tree->root->node_ID]);
											}
										}
										DF_tmp = DF_tmp->next;
									}
								}
							}
							tmp = tmp->next;
						}
					}
				}
				map<unsigned int, tree_info_index*>::iterator index_iter2 = v2t_index.find(src_state);
				if (index_iter2 != v2t_index.end())
				{
					unordered_map<unsigned int, tree_info*>::iterator tree_iter = index_iter2->second->tree_index.find(s); // we update all the normal trees containing this node
					if (tree_iter != index_iter2->second->tree_index.end()) {
						tree_info* tmp = tree_iter->second;
						while (tmp)
						{
							unsigned int root_ID = tmp->tree->root->node_ID;
							unsigned int root_state = tmp->tree->root->state;
							unsigned long long root_info = merge_long_long(root_ID, root_state);
							unordered_map<unsigned long long, unsigned int> updated_de;
							insert_edge_normal_tree(s, d, label, timestamp, src_state, dst_state, tmp->tree, updated_de);
							if (updated_de.empty()) {
								tmp = tmp->next;
								continue;
							}
							RPQ_tree* DF_tree;
							if (DF_forest.find(merge_long_long(root_ID, 0)) == DF_forest.end())
							{
								DF_tree = new RPQ_tree();
								DF_tree->root = add_df_node(DF_tree, root_ID, 0, root_ID, NULL, MAX_INT, MAX_INT);
								DF_forest[merge_long_long(root_ID, 0)] = DF_tree;
							}
							else
								DF_tree = DF_forest[merge_long_long(root_ID, 0)];
							batch_insert_edge_df_tree(root_ID, root_state, updated_de, DF_tree, dependency_paths[root_ID]);
							tmp = tmp->next;
						}
					}
				}
	
				for (unordered_map<unsigned int, unordered_map<unsigned long long, unsigned int>>::iterator iter = dependency_paths.begin(); iter != dependency_paths.end(); iter++)
				{
					unsigned int root_ID = iter->first;
					for (unordered_map<unsigned long long, unsigned int>::iterator iter2 = iter->second.begin(); iter2 != iter->second.end(); iter2++)
					{
						unordered_map<unsigned int, unsigned int> final_nodes;
						get_final_nodes(iter2->first, final_nodes);
						update_result(final_nodes, root_ID, iter2->second);
					}
					iter->second.clear();
				}
				dependency_paths.clear();
			}
		}

	}
	void expand_in_recover(tree_node* expand_node, RPQ_tree* tree_pt, bool lm_expand_tree = false)
	{
		 unsigned int root_ID = tree_pt->root->node_ID;
                unsigned int root_state = tree_pt->root->state;
                unsigned int root_info = merge_long_long(root_ID, root_state);
                priority_queue<tree_node*, vector<tree_node*>, time_compare> q;
                q.push(expand_node);
                while (!q.empty())
                {
                        tree_node* tmp = q.top();
                        q.pop();
                        unsigned long long info = merge_long_long(tmp->node_ID, tmp->state);
                        if (landmarks.find(info) != landmarks.end())
                        {
                                tmp->lm = true;
                                tree_pt->add_timed_lm(info, tmp->timestamp);
                                continue;
                        }


                        map<int, int> aut_edge;
                        aut->get_all_suc(tmp->state, aut_edge); // get the edges acceptable to the src state
                        vector<edge_info>sucs;
                        g->get_timed_all_suc(tmp->node_ID, sucs); // get out edges of the src node
                        for (int i = 0; i < sucs.size(); i++)
                        {
                                unsigned int successor = sucs[i].d;
                                unsigned int label = sucs[i].label;
                                unsigned int time = min(tmp->timestamp, sucs[i].timestamp);
                                if (aut_edge.find(label) == aut_edge.end())
                                        continue;
                                int dst_state = aut_edge[label];

                                if (tree_pt->node_map.find(dst_state) == tree_pt->node_map.end() || tree_pt->node_map[dst_state]->index.find(successor) == tree_pt->node_map[dst_state]->index.end()) // if this node does not exist yet.
                                {
                                        tree_node* new_node;
                                        if (lm_expand_tree)
                                                new_node = add_lm_node(tree_pt, successor, dst_state, tree_pt->root->node_ID, tree_pt->root->state, tmp, time, sucs[i].timestamp);
                                        else
                                                new_node = add_node(tree_pt, successor, dst_state, tree_pt->root->node_ID, tmp, time, sucs[i].timestamp);
                                        q.push(new_node);
                                }
                                else
                                {
                                        tree_node* dst_pt = tree_pt->node_map[dst_state]->index[successor];
                                        if (dst_pt->timestamp < time) // if the node exists but has a smaller timestamp
                                        {
                                                if (dst_pt->parent != tmp)
                                                        tree_pt->substitute_parent(tmp, dst_pt);
                                                dst_pt->timestamp = time;
                                                dst_pt->edge_timestamp = sucs[i].timestamp;
                                                q.push(dst_pt);
                                        }
                                }
                        }
                }

	}


	void switch_tree_index(RPQ_tree* tree_pt) // this function switch the reverse index of nodes in tree_pt from v2t_index to v2l_index, used when tree_pt is transformed into an LM tree.
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		for (map<unsigned int, tree_node_index*>::iterator iter = tree_pt->node_map.begin(); iter != tree_pt->node_map.end(); iter++)
		{
			for (unordered_map<unsigned int, tree_node*>::iterator iter2 = iter->second->index.begin(); iter2 != iter->second->index.end(); iter2++)
			{
				delete_index(iter2->first, iter2->second->state, root_ID);
				add_lm_index(tree_pt, iter2->first, iter2->second->state, root_ID, root_state);
			}
		}
	}

	void switch_tree_index_reverse(RPQ_tree* tree_pt) // this function switch the reverse index of nodes in tree_pt from v2l_index to v2t_index, used when tree_pt is transformed from an LM tree to a normal tree.
	{
		unsigned int root_ID = tree_pt->root->node_ID;
		unsigned int root_state = tree_pt->root->state;
		for (map<unsigned int, tree_node_index*>::iterator iter = tree_pt->node_map.begin(); iter != tree_pt->node_map.end(); iter++)
		{
			for (unordered_map<unsigned int, tree_node*>::iterator iter2 = iter->second->index.begin(); iter2 != iter->second->index.end(); iter2++)
			{
				delete_lm_index(iter2->first, iter2->second->state, root_ID, root_state);
				add_index(tree_pt, iter2->first, iter2->second->state, root_ID);
			}
		}
	}
	void recover_subtree(unsigned int v, unsigned int state, RPQ_tree* lm_tree) // this function recovers the subtrees of a deleted landmark (v, state) in normal trees, lm_tree is the LM tree of this landmark.
	{
		map<unsigned, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end())
			{
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					tree_pt->timed_landmarks.erase(merge_long_long(v, state));
					shrink(tree_pt->timed_landmarks);
					tree_node* lm_node = tree_pt->find_node(v, state);
					lm_node->lm = false;
					if (lm_tree) {
						if (tree_pt->root->node_ID != v || tree_pt->root->state != state)
							expand_in_recover(lm_node, tree_pt, false);
					}
					tmp = tmp->next;
				}
			}
		}
	}

	void recover_subtree_lm(unsigned int v, unsigned int state, RPQ_tree* lm_tree) // this function recovers the subtrees of a deleted landmark (v, state) in other LM trees, lm_tree is the LM tree of this landmark.
	{
		map<unsigned, lm_info_index*>::iterator iter = v2l_index.find(state);
		if (iter != v2l_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					unsigned int root_state = tree_pt->root->state;
					unsigned int root_ID = tree_pt->root->node_ID;
					tree_pt->timed_landmarks.erase(merge_long_long(v, state));
					shrink(tree_pt->timed_landmarks);
					tree_node* lm_node = tree_pt->find_node(v, state);
					lm_node->lm = false;
					if (lm_tree) {
						if (tree_pt->root->node_ID != v || tree_pt->root->state != state) { // in LM trees, we can quickly  decide if the local path is latest with time info map
							expand_in_recover(lm_node, tree_pt, true);
						}
					}
					tmp = tmp->next;
				}
			}
		}
	}

	void modify_DF_lm_retire(unsigned v, unsigned state)
	{
		map<unsigned int, tree_info_index*>::iterator DF_iter = v2d_index.find(state);
		if (DF_iter != v2d_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator DF_tree_iter = DF_iter->second->tree_index.find(v);
			if (DF_tree_iter != DF_iter->second->tree_index.end()) {
				tree_info* DF_tmp = DF_tree_iter->second;
				vector<RPQ_tree*> tree_to_delete;
				while (DF_tmp)
				{
					tree_to_delete.push_back(DF_tmp->tree);
					DF_tmp = DF_tmp->next;
				}
				for(int i=0;i<tree_to_delete.size();i++){
					RPQ_tree* DF_tree = tree_to_delete[i];
					if (DF_tree->root->node_ID == v && DF_tree->root->state == state)
						continue;
					if (DF_tree->node_map.find(state) != DF_tree->node_map.end())
					{
						if (DF_tree->node_map[state]->index.find(v) != DF_tree->node_map[state]->index.end())
						{
							tree_node* lm_DF_node = DF_tree->node_map[state]->index[v];
							tree_node* parent = lm_DF_node->parent;
							tree_node* child = lm_DF_node->child;
							while (child)
							{
								tree_node* next = child->brother;
								child->parent = parent;
								child->brother = parent->child;
								parent->child = child;
								child->edge_timestamp = min(lm_DF_node->edge_timestamp, child->edge_timestamp);
								child = next;
							}
							DF_tree->delete_node(lm_DF_node);
							delete_df_index(v, state, DF_tree->root->node_ID);
							if (DF_tree->root->child == NULL)
							{
								delete_df_index(DF_tree->root->node_ID, DF_tree->root->state, DF_tree->root->node_ID);
								DF_forest.erase(merge_long_long(DF_tree->root->node_ID, DF_tree->root->state));
								delete DF_tree;
							}
						}
					}
				}
			}
		}
	}

	void retrieve_subtree(unsigned int v, unsigned int state) // this function delete the subtree of a landmark (v, state) in normal trees.
	{
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
				//	if(tree_pt->root->node_ID==153446&&v==136258)
				//		print_tree(tree_pt->root->node_ID, tree_pt->root->state);
					tree_node* lm_node = tree_pt->find_node(v, state);
					lm_node->lm = true;
					tree_pt->timed_landmarks[merge_long_long(v, state)] = lm_node->timestamp; // add the new landmark to the landmark set of the normal tree
					tree_node* child = lm_node->child;  // carry out a BFS starting from childs of this landmark, and delete all the succesors in its subtree.
					lm_node->child = NULL;
					queue<tree_node*> q;
					while (child)
					{
						q.push(child);
						child = child->brother;
					}
					while (!q.empty())
					{
						tree_node* cur = q.front();
						q.pop();
						delete_index(cur->node_ID, cur->state, tree_pt->root->node_ID);
						child = cur->child;
						while (child)
						{
							q.push(child);
							child = child->brother;
						}
						assert(tree_pt->node_map.find(cur->state) != tree_pt->node_map.end());
						tree_pt->node_map[cur->state]->index.erase(cur->node_ID);
						shrink(tree_pt->node_map[cur->state]->index);
						if (tree_pt->node_map[cur->state]->index.empty()) {
							delete tree_pt->node_map[cur->state];
							tree_pt->node_map.erase(cur->state);
						}
						if (cur->lm) {
							tree_pt->timed_landmarks.erase(merge_long_long(cur->node_ID, cur->state));
							shrink(tree_pt->timed_landmarks);
						}
						delete cur;
						tree_pt->node_cnt--;
					}
					tmp = tmp->next;
				}
			}
		}
	}

	void retrieve_subtree_lm(unsigned int v, unsigned int state, RPQ_tree* lm_tree)
	{
		map<unsigned int, lm_info_index*>::iterator iter = v2l_index.find(state);
		if (iter != v2l_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					if (tree_pt->root->node_ID == v && tree_pt->root->state == state) // we need to skip lm_tree itself;
					{
						tmp = tmp->next;
						continue;
					}
					tree_node* lm_node = tree_pt->find_node(v, state);
					lm_node->lm = true;
					tree_pt->timed_landmarks[merge_long_long(v, state)] = lm_node->timestamp;
					tree_node* child = lm_node->child;
					lm_node->child = NULL;
					queue<tree_node*> q;
					while (child)
					{
						q.push(child);
						child = child->brother;
					}
					while (!q.empty())
					{
						tree_node* cur = q.front();
						q.pop();
						delete_lm_index(cur->node_ID, cur->state, tree_pt->root->node_ID, tree_pt->root->state);
						child = cur->child;
						while (child)
						{
							q.push(child);
							child = child->brother;
						}

						tree_pt->node_map[cur->state]->index.erase(cur->node_ID);
						shrink(tree_pt->node_map[cur->state]->index);
						if (tree_pt->node_map[cur->state]->index.empty()) {
							delete tree_pt->node_map[cur->state];
							tree_pt->node_map.erase(cur->state);
						}
						if (cur->lm) {
							tree_pt->timed_landmarks.erase(merge_long_long(cur->node_ID, cur->state));
							shrink(tree_pt->timed_landmarks);
						}
						delete cur;
						tree_pt->node_cnt--;
					}
					tmp = tmp->next;
				}
			}

		}
	}
	void modify_DF_lm_select(unsigned v, unsigned state)
	{
		unordered_map<unsigned long long, unsigned int> successors;
		get_DG_successor(merge_long_long(v, state), successors);
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					if (tree_pt->node_map.find(state) != tree_pt->node_map.end())
					{
						if (tree_pt->node_map[state]->index.find(v) != tree_pt->node_map[state]->index.end())
						{
							unsigned int df_edge_time = tree_pt->node_map[state]->index[v]->timestamp;
							if (DF_forest.find(merge_long_long(tree_pt->root->node_ID, tree_pt->root->state)) == DF_forest.end())
							{
								RPQ_tree* DF_tree = new RPQ_tree;
								tree_node* root = add_df_node(DF_tree, tree_pt->root->node_ID, tree_pt->root->state, tree_pt->root->node_ID, NULL, MAX_INT, MAX_INT);
								DF_tree->root = root;
								add_df_node(DF_tree, v, state, tree_pt->root->node_ID, root, df_edge_time, df_edge_time);
								DF_forest[merge_long_long(tree_pt->root->node_ID, tree_pt->root->state)] = DF_tree;
							}
							else
							{
								RPQ_tree* DF_tree = DF_forest[merge_long_long(tree_pt->root->node_ID, tree_pt->root->state)];
								tree_node* lm_node = add_df_node(DF_tree, v, state, tree_pt->root->node_ID, DF_tree->root, df_edge_time, df_edge_time);
								for (unordered_map<unsigned long long, unsigned int>::iterator iter = successors.begin(); iter != successors.end(); iter++)
								{
									tree_node* child = DF_tree->find_node((iter->first>>32), (iter->first&0xFFFFFFFF));
									if (child != NULL&&child->timestamp<=min(lm_node->timestamp, iter->second))
									{
										child->edge_timestamp = iter->second;
										child->timestamp = min(lm_node->timestamp, iter->second);
										DF_tree->substitute_parent(lm_node, child);
									}
								}
							}
						}
					}
					tmp = tmp->next;
				}
			}
		}
		map<unsigned int, lm_info_index*>::iterator iter2 = v2l_index.find(state);
		if (iter2 != v2l_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter2->second->tree_index.find(v);
			tree_info* tmp = tree_iter->second;
			while (tmp)
			{
				RPQ_tree* tree_pt = tmp->tree;
				unsigned int root_ID = tree_pt->root->node_ID;
				unsigned int root_state = tree_pt->root->state;
				if (tree_pt->node_map.find(state) != tree_pt->node_map.end())
				{
					if (tree_pt->node_map[state]->index.find(v) != tree_pt->node_map[state]->index.end())
					{
						unsigned int df_edge_time = tree_pt->node_map[state]->index[v]->timestamp;
						if (tree_pt->root->state==0&&DF_forest.find(merge_long_long(tree_pt->root->node_ID, tree_pt->root->state)) == DF_forest.end())
						{
							RPQ_tree* DF_tree = new RPQ_tree;
							tree_node* root = add_df_node(DF_tree, tree_pt->root->node_ID, tree_pt->root->state, tree_pt->root->node_ID, NULL, MAX_INT, MAX_INT);
							DF_tree->root = root;
							add_df_node(DF_tree, v, state, tree_pt->root->node_ID, root, df_edge_time, df_edge_time);
							DF_forest[merge_long_long(tree_pt->root->node_ID, tree_pt->root->state)] = DF_tree;
						}
							if (v2d_index.find(root_state) != v2d_index.end())
							{
								if (v2d_index[root_state]->tree_index.find(root_ID) != v2d_index[root_state]->tree_index.end())
								{
									tree_info* DF_tmp = v2d_index[root_state]->tree_index[root_ID];
									while (DF_tmp)
									{
										RPQ_tree* DF_tree = DF_tmp->tree;
										tree_node* lm_node = DF_tree->find_node(v, state);
										tree_node* parent = DF_tree->find_node(root_ID, root_state);
										assert(parent);
										if (!lm_node) {
											lm_node = add_df_node(DF_tree, v, state, DF_tree->root->node_ID, parent, min(parent->timestamp, df_edge_time), df_edge_time);
											unordered_set<unsigned long long> ancestors;
											tree_node* cur = parent;
											while (cur)
											{
												ancestors.insert(merge_long_long(cur->node_ID, cur->state));
												cur = cur->parent;
											}
											for (unordered_map<unsigned long long, unsigned int>::iterator iter = successors.begin(); iter != successors.end(); iter++)
											{
												if (ancestors.find(iter->first) != ancestors.end())
													continue;
												tree_node* child = DF_tree->find_node((iter->first >> 32), (iter->first & 0xFFFFFFFF));
												if (child != NULL && child->timestamp <= min(lm_node->timestamp, iter->second))
												{
													child->edge_timestamp = iter->second;
													child->timestamp = min(lm_node->timestamp, iter->second);
													DF_tree->substitute_parent(lm_node, child);
												}
											}
										}
										else
										{
											lm_node = DF_tree->find_node(v, state);
											if (lm_node->timestamp < min(parent->timestamp, df_edge_time))
											{
												lm_node->edge_timestamp = df_edge_time;
												lm_node->timestamp = min(parent->timestamp, df_edge_time);
												DF_tree->substitute_parent(parent, lm_node);
												unordered_set<unsigned long long> ancestors;
												tree_node* cur = parent;
												while (cur)
												{
													ancestors.insert(merge_long_long(cur->node_ID, cur->state));
													cur = cur->parent;
												}
												for (unordered_map<unsigned long long, unsigned int>::iterator iter = successors.begin(); iter != successors.end(); iter++)
												{
													if (ancestors.find(iter->first) != ancestors.end())
														continue;
													tree_node* child = DF_tree->find_node((iter->first >> 32), (iter->first & 0xFFFFFFFF));
													if (child != NULL && child->timestamp <= min(lm_node->timestamp, iter->second))
													{
														child->edge_timestamp = iter->second;
														child->timestamp = min(lm_node->timestamp, iter->second);
														DF_tree->substitute_parent(lm_node, child);
													}
												}
												ancestors.clear();
											}
										}
										DF_tmp = DF_tmp->next;
									}
								}
							}
					}
				}
				tmp = tmp->next;
			}
		}
	}
	RPQ_tree* build_lm_tree(unsigned int v, unsigned int state) // this function build new lm tree for a landmark, we use time info in prune and may miss some nodes, we will add them back with above fulfill_new_lm_tree later .
	{
		RPQ_tree* new_tree = new RPQ_tree;
		new_tree->root = new_tree->add_node(v, state, NULL, MAX_INT, MAX_INT);
		queue<tree_node*> q;
		q.push(new_tree->root);
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			if (tmp != new_tree->root && landmarks.find(merge_long_long(tmp->node_ID, tmp->state)) != landmarks.end())
			{
				tmp->lm = true;
				new_tree->add_timed_lm(merge_long_long(tmp->node_ID, tmp->state), tmp->timestamp);
				continue;
			}

			map<int, int> aut_edge;
			aut->get_all_suc(tmp->state, aut_edge);
			vector<edge_info>sucs;
			g->get_timed_all_suc(tmp->node_ID, sucs);
			for (int i = 0; i < sucs.size(); i++)
			{
				unsigned int successor = sucs[i].d;
				unsigned int label = sucs[i].label;
				unsigned int time = min(tmp->timestamp, sucs[i].timestamp);
				if (aut_edge.find(label) == aut_edge.end())
					continue;
				int dst_state = aut_edge[label];

				if (new_tree->node_map.find(dst_state) == new_tree->node_map.end() || new_tree->node_map[dst_state]->index.find(successor) == new_tree->node_map[dst_state]->index.end())
				{
					tree_node* new_node = new_tree->add_node(successor, dst_state, tmp, time, sucs[i].timestamp);
					q.push(new_node);
				}
				else
				{
					tree_node* dst_pt = new_tree->node_map[dst_state]->index[successor];
					if (dst_pt->timestamp < time)
					{
						if (dst_pt->parent != tmp)
							new_tree->substitute_parent(tmp, dst_pt);
						dst_pt->timestamp = time;
						dst_pt->edge_timestamp = sucs[i].timestamp;
						q.push(dst_pt);
					}
				}
			}
		}
		return new_tree;
	}

	void build_v2l_index(RPQ_tree* new_tree) // this function build the reverse index given a new LM tree, we do not build the reverse index during LM tree building, as the LM tree may not become valid. 
	{
		queue<tree_node*> q;
		q.push(new_tree->root);
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			add_lm_index(new_tree, tmp->node_ID, tmp->state, new_tree->root->node_ID, new_tree->root->state);
			tree_node* child = tmp->child;
			while (child)
			{
				q.push(child);
				child = child->brother;
			}
		}
	}

	bool count_presence(unsigned int id, unsigned int state, unsigned int threshold) // this function count the number of presences of a node in the forest, and returns true once it exceeds the threshold.
	{
		unsigned int sum = 0;
		if (v2t_index.find(state) != v2t_index.end()) {
			tree_info_index* index = v2t_index[state];
			if (index->tree_index.find(id) != index->tree_index.end())
			{
				tree_info* tmp = index->tree_index[id];
				while (tmp)
				{
					sum++;
					if (sum >= threshold)
						return true;
					tmp = tmp->next;
				}
			}
		}
		if (v2l_index.find(state) != v2l_index.end()) {
			lm_info_index* index = v2l_index[state];
			if (index->tree_index.find(id) != index->tree_index.end())
			{
				tree_info* tmp = index->tree_index[id];
				while (tmp)
				{
					sum++;
					if (sum >= threshold)
						return true;
					tmp = tmp->next;
				}
			}
		}
		return false;
	}


	int recover_subtree_preview(unsigned int v, unsigned int state, RPQ_tree* lm_tree, int node_budget) // this function predicts the number of nodes we need to add back in normal trees once we delete a landmark from the landmark set.
		// if the number of nodes exceeds the node_budget, we stop the counting and return. lm_tree is the LM tree of the landmark we try to delete. 
	{
		unsigned int node_cnt = 0;
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end())
			{
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					for (map<unsigned int, tree_node_index*>::iterator node_iter1 = lm_tree->node_map.begin(); node_iter1 != lm_tree->node_map.end(); node_iter1++)
					{
						for (unordered_map<unsigned int, tree_node*>::iterator node_iter2 = node_iter1->second->index.begin(); node_iter2 != node_iter1->second->index.end(); node_iter2++)
						{
							if (tree_pt->find_node(node_iter2->first, node_iter1->first) == NULL)
							{
								node_budget--; // the number of nodes is predicted as the number of nodes in the lm_tree but not in the normal tree, in this prediction we do not bother to check if the local path to 
								// the landmark is latest, as it needs considerabel computation in normal trees. As a result the prediction will be larger than the fact.
							}
						}
					}
					if (node_budget <= 0)
						return 0;
					tmp = tmp->next;
				}
			}
		}
		return node_budget;
	}
	int recover_subtree_lm_preview(unsigned int v, unsigned int state, RPQ_tree* lm_tree, int node_budget) // this function predicts the number of nodes we need to add back in LM trees once we delete a landmark from the landmark set.
		// if the number of nodes exceeds the node_budget, we stop the counting and return. lm_tree is the LM tree of the landmark we try to delete. 
	{
		unsigned int node_cnt = 0;
		map<unsigned int, lm_info_index*>::iterator iter = v2l_index.find(state);
		if (iter != v2l_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end())
			{
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					if (tree_pt->root->node_ID == v && tree_pt->root->state == state) // skip lm_tree itself.
					{
						tmp = tmp->next;
						continue;
					}
					for (map<unsigned int, tree_node_index*>::iterator node_iter1 = lm_tree->node_map.begin(); node_iter1 != lm_tree->node_map.end(); node_iter1++)
					{
						for (unordered_map<unsigned int, tree_node*>::iterator node_iter2 = node_iter1->second->index.begin(); node_iter2 != node_iter1->second->index.end(); node_iter2++)
						{
							if (tree_pt->find_node(node_iter2->first, node_iter1->first) == NULL)
							{
								node_budget--;
							}
						}
					}
					if (node_budget <= 0)
						return 0;
					tmp = tmp->next;
				}
			}
		}
		return node_budget;
	}
	unsigned int retrieve_subtree_preview(unsigned int v, unsigned int state) // the function count the number of nodes in the subtree of (v, state) in normal trees.
	{
		unsigned int node_cnt = 0;
		map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(state);
		if (iter != v2t_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(v);
			if (tree_iter != iter->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					if (tree_pt->root->node_ID == v && tree_pt->root->state == state) // skip the normal tree of (v, state) itself. As (v, state) is not a landmark yet, there may be a normal tree rooted at it if state = 0;
					{
						tmp = tmp->next;
						continue;
					}
					tree_node* lm_node = tree_pt->find_node(v, state);
					queue<tree_node*> q;
					q.push(lm_node);
					while (!q.empty())
					{
						tree_node* cur = q.front();
						q.pop();
						node_cnt++;
						tree_node* child = cur->child;
						while (child)
						{
							q.push(child);
							child = child->brother;
						}
					}
					node_cnt--; // the landmark itself should not be counted.
					tmp = tmp->next;
				}
			}
		}
		return node_cnt;
	}
	unsigned int retrieve_subtree_lm_preview(unsigned int v, unsigned int state) // the function count the number of nodes in the subtree of (v, state) in LM trees.
	{
		unsigned int node_cnt = 0;
		map<unsigned int, lm_info_index*>::iterator iter2 = v2l_index.find(state);
		if (iter2 != v2l_index.end())
		{
			unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter2->second->tree_index.find(v);
			if (tree_iter != iter2->second->tree_index.end()) {
				tree_info* tmp = tree_iter->second;
				while (tmp)
				{
					RPQ_tree* tree_pt = tmp->tree;
					tree_node* lm_node = tree_pt->find_node(v, state);
					queue<tree_node*> q;
					q.push(lm_node);
					while (!q.empty())
					{
						tree_node* cur = q.front();
						q.pop();
						node_cnt++;
						tree_node* child = cur->child;
						while (child)
						{
							q.push(child);
							child = child->brother;
						}
					}
					node_cnt--; // the landmark itself should not be counted.
					tmp = tmp->next;
				}
			}
		}
		return node_cnt;
	}

	void delete_v2l_index(RPQ_tree* tree_pt) // this function delete the reverse index of nodes in a LM tree.
	{
		queue<tree_node*> q;
		q.push(tree_pt->root);
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			for (tree_node* cur = tmp->child; cur; cur = cur->brother)
				q.push(cur);
			delete_lm_index(tmp->node_ID, tmp->state, tree_pt->root->node_ID, tree_pt->root->state);
		}
	}

	void dynamic_lm_select(double candidate_rate, double benefit_threshold) // the function to select landmarks, first parameter is the candidate selection rate, usually 0.2, the second is the benefit threshold, usually 1.5 
	{
		vector<vertex_score> scores;
		unordered_map<unsigned long long, unsigned int> score_map; //store scores of nodes
		for (unordered_map<unsigned int, neighbor_list>::iterator iter = g->g.begin(); iter != g->g.end(); iter++)
		{
			unsigned int degree_sum = 0;
			unsigned int id = iter->first;
			for (unordered_map<int, automat_edge*>::iterator iter2 = aut->g.begin(); iter2 != aut->g.end(); iter2++)
			{
				unsigned int state = iter2->first;
				unsigned long long info = merge_long_long(id, state);
				if (count_presence(id, state, 2)) {  // filter out product graph nodes which appear in less than 2 trees.
					map<unsigned int, unsigned int> degree_map;
					g->get_src_degree(id, degree_map);
					degree_sum = 0;
					automat_edge* tmp = iter2->second; // only include the edges with acceptable labels in degree counting.
					while (tmp) {
						if (degree_map.find(tmp->label) != degree_map.end())
							degree_sum += degree_map[tmp->label];
						tmp = tmp->next;
					}
					if (degree_sum > 0)
					{
						double score = degree_sum * aut_scores[state]; // aut_scores record the approximated depth of the tree, computed based on the state. 
						if (score > 1) {
							scores.push_back(vertex_score(id, state, score));
							score_map[merge_long_long(id, state)] = score;
						}
					}
				}
			}
		}
		if (scores.size() == 0)
			return;
		sort(scores.begin(), scores.end()); // socrt the scores.


		unsigned int num = scores.size() * candidate_rate;
		if (num == 0)
			num++;
		double bar = scores[scores.size() - num].score; // nodes with score smaller than this bar is not in the candidate set.

		for (unordered_set<unsigned long long>::iterator it = landmarks.begin(); it != landmarks.end(); ) // check current landmarks
		{
			unsigned long long info = *it;
			unsigned int v = (info >> 32);
			unsigned int state = (info & 0xFFFFFFFF);
			RPQ_tree* tree_pt = NULL;
			if (forests.find(info) != forests.end()) // if the LM tree of this landmark is already deleted because it becomes empty in expiration, this landmark need to be deleted from the landmark set.
				tree_pt = forests[info];
			else
			{
				it = landmarks.erase(it);
				continue;
			}

			if (score_map.find(info) == score_map.end() || score_map[info] < bar) // if it is not a candidate any more.
			{
				it = landmarks.erase(it);
				recover_subtree(v, state, tree_pt);
				recover_subtree_lm(v, state, tree_pt); // rcover the subtrees
				if (state == 0) { // if the state is 0, we need to transform the LM tree back to a normal tree.
					switch_tree_index_reverse(tree_pt); // swith the reverse index of the nodes in it from v2h to v2l
				}
				else // else we need to delete this tree.
				{
					delete_v2l_index(tree_pt);
					delete tree_pt;
					forests.erase(info);
				}
				modify_DF_lm_retire(v, state);
				continue;
			}
			else if (state != 0) // if the state is 0, there should be a delta tree with (v state) any way. In this case, as long as there is another subtree with (v, state), selecting it will bring decrease to the forests, thus we donot need to check
			{
				int node_budget = tree_pt->node_cnt * benefit_threshold; // the number of omitedd nodes in the subtrees need to be larger than this threshold.
				node_budget = recover_subtree_lm_preview(v, state, tree_pt, node_budget);
				if (node_budget > 0)
					node_budget = recover_subtree_preview(v, state, tree_pt, node_budget);
				if (node_budget > 0) // if not, delete it from the landmark
				{
					it = landmarks.erase(it);
					recover_subtree(v, state, tree_pt);
					recover_subtree_lm(v, state, tree_pt);
					delete_v2l_index(tree_pt);
					delete tree_pt;
					forests.erase(info);
					modify_DF_lm_retire(v, state);
				}
				else
					it++;
			}
			else
				it++;
		}

		shrink(landmarks);



		for (int i = scores.size() - 1; i + num >= scores.size(); i--) // scan candidates
		{
			unsigned int v = scores[i].ID;
			unsigned int state = scores[i].state;
			unsigned long long info = merge_long_long(v, state);
			if (landmarks.find(info) != landmarks.end()) // skip a node if it is already a landmark
				continue;

			RPQ_tree* tree_pt = NULL;
			if (forests.find(info) != forests.end()) { // if there is already a normal tree for it, it mush have state 0, and should be selected as a landmark.
				tree_pt = forests[info];
				switch_tree_index(tree_pt);
				retrieve_subtree(v, state); // delete the subtree in normal trees
				retrieve_subtree_lm(v, state, tree_pt); // delete subtree in LM trees, and necessary nodes which may be missing in the LM tree building.
				landmarks.insert(info);
				modify_DF_lm_select(v, state);
			}
			else // else we need to trade off the benefit and cost
			{
				tree_pt = build_lm_tree(v, state);  // we build the LM tree first. 
				unsigned int node_cost = tree_pt->node_cnt; // cost is the LM tree size
				unsigned int node_benefit = retrieve_subtree_lm_preview(v, state);
				node_benefit += retrieve_subtree_preview(v, state); // benefit is the size of subtrees.
				if (node_benefit < node_cost * benefit_threshold) // if the benefit is not enough, delete the LM tree we just build
					delete tree_pt;
				else // this candidate is a landmark
				{
					forests[info] = tree_pt;		// add the LM tree into forest.
					build_v2l_index(tree_pt); // build reverse index
					retrieve_subtree(v, state);
					retrieve_subtree_lm(v, state, tree_pt); // delete subtrees and collect necessary nodes
					landmarks.insert(info);
					modify_DF_lm_select(v, state);
				}
			}
		}
	}
	void output_match(ofstream& fout)
	{
		for (unordered_map<unsigned long long, unsigned int>::iterator iter = result_pairs.begin(); iter != result_pairs.end(); iter++)
			fout << (iter->first >> 32) << " " << (iter->first & 0xFFFFFFFF) << " " << iter->second << endl;
	}
	void count(ofstream& fout) // count the memory used in the algorithm, but exclude the memory of automaton and streaming graph, because they are essential for any algorithm.
	{
		unsigned int us_size = sizeof(unordered_set<unsigned int>); // size of statistics in a unordered_set, which does not change with the key-value type, usually is 56, but may change with the system.
		unsigned int um_size = sizeof(unordered_map<unsigned int, unsigned int>); // size of statistics in a map, which does not change with the key-value type, usually is 56, but may change with the system.
		unsigned int m_size = sizeof(map<unsigned int, unsigned int>); // size of pointers and statistics in a map, which does not change with the key-value type, usually is 48, but may change with the system.

		cout << "result pair size: " << result_pairs.size() << ", memory: " << ((double)(um_size + result_pairs.size() * 24 + result_pairs.bucket_count() * 8) / (1024 * 1024)) << endl;   // number of result vertex pairs, and the memory used to store these results.
		fout << "result pair size: " << result_pairs.size() << ", memory: " << ((double)(um_size + result_pairs.size() * 24 + result_pairs.bucket_count() * 8) / (1024 * 1024)) << endl;

		cout << "landmark number " << landmarks.size() << " tree number " << forests.size() << " snapshot graph vertice number " << g->get_vertice_num() << endl;
		fout << "landmark number " << landmarks.size() << " tree number " << forests.size() << " snapshot graph vertice number " << g->get_vertice_num() << endl;

		unsigned int tree_size = 16 + m_size * 2 + us_size; // size of statistics and pointers in a tree
		double tree_memory = ((double)(um_size + forests.bucket_count() * 8 + forests.size() * (24 + tree_size)) / (1024 * 1024)); // forest is a unordered_map (um), each KV is 16 byte, 8 byte long long + 8 byte pointer,
		// plus a pointer pointing to the next KV in the list. Each bucket has a pointer pointing to the head of the value list in this bucket. Memory of following us is computed similarly. size of statistics of each tree is also calculated here.
		double DF_tree_memory = ((double)(um_size + DF_forest.bucket_count() * 8 + DF_forest.size() * (24 + tree_size)) / (1024 * 1024));
		double global_lm_memory = ((double)(us_size + landmarks.size() * 16 + landmarks.bucket_count() * 8) / (1024 * 1024)); // size of the unordered_set (us) landmarks, each value is a 8 byte long long, associated with a pointer pointing to next value in the list.
		// each bucket has a pointer pointing to the head of the value list in this bucket. Memory of following us is computed similarly.
		double lm_set_memory = 0; // memory of landmark set in trees.
		double time_info_memory = 0; // memory of time info map
		double lm_node_memory = 0; // memmory of nodes and reverse indexes for LM trees.
		double tree_node_memory = 0; // memmory of nodes and reverse indexes for normal trees.
		double DF_node_memory = 0;
		for (unordered_map<unsigned long long, RPQ_tree*>::iterator iter = forests.begin(); iter != forests.end(); iter++)
		{
			RPQ_tree* tree_pt = iter->second;
			lm_set_memory += tree_pt->timed_landmarks.bucket_count() * 8 + tree_pt->timed_landmarks.size() * 24;
			time_info_memory += tree_pt->time_info.size() * 40; // first layer is a map, and each KV is 24 byte, 3 pointer is associated (parent, left child, right child)
			for (map<unsigned int, time_info_index*>::iterator iter2 = tree_pt->time_info.begin(); iter2 != tree_pt->time_info.end(); iter2++) {
				time_info_memory += um_size + iter2->second->index.bucket_count() * 8 + iter2->second->index.size() * 16; // second layer is a um, and each KV is 8 byte.
			}
			unsigned long long info = merge_long_long(tree_pt->root->node_ID, tree_pt->root->state);
			bool lm_root = false;
			if (landmarks.find(info) != landmarks.end())
				lm_root = true; // marks if it is an LM tree
			double node_memory = 0;
			node_memory += tree_pt->node_map.size() * 40; // first layer of the node map is a map
			for (map<unsigned int, tree_node_index*>::iterator iter2 = tree_pt->node_map.begin(); iter2 != tree_pt->node_map.end(); iter2++)
				node_memory += um_size + iter2->second->index.bucket_count() * 8 + iter2->second->index.size() * (24 + 48); // second layer is a um, each KV is 16 byte, memory of the tree node is also computed here.
			if (lm_root)
				lm_node_memory += node_memory;
			else
				tree_node_memory += node_memory;
		}
		for (unordered_map<unsigned long long, RPQ_tree*>::iterator iter = DF_forest.begin(); iter != DF_forest.end(); iter++)
		{
			RPQ_tree* tree_pt = iter->second;	
			double node_memory = 0;
			node_memory += tree_pt->node_map.size() * 40; // first layer of the node map is a map
			for (map<unsigned int, tree_node_index*>::iterator iter2 = tree_pt->node_map.begin(); iter2 != tree_pt->node_map.end(); iter2++)
				node_memory += um_size + iter2->second->index.bucket_count() * 8 + iter2->second->index.size() * (24 + 48); // second layer is a um, each KV is 16 byte, memory of the tree node is also computed here.
			DF_node_memory += node_memory;
		}
		lm_set_memory = ((lm_set_memory) / (1024 * 1024));
		time_info_memory = (time_info_memory / (1024 * 1024));
		cout << "memory usage of time info in lm trees: " << time_info_memory << endl;
		fout << "memory usage of time info in lm trees: " << time_info_memory << endl;

		// calculate memory of the reverse index from node to tree.

		unsigned int lm_node_num = 0;
		lm_node_memory += m_size + v2l_index.size() * 40; // firt layer is a map
		for (map<unsigned int, lm_info_index*>::iterator iter = v2l_index.begin(); iter != v2l_index.end(); iter++)
		{
			lm_node_memory += um_size + m_size; // each second layer lm_info_index has a um and a map
			lm_node_memory += iter->second->tree_index.bucket_count() * 8 + iter->second->tree_index.size() * 24;  // memory of the um, each KV has 16 bytes.
			for (unordered_map<unsigned int, tree_info*>::iterator iter2 = iter->second->tree_index.begin(); iter2 != iter->second->tree_index.end(); iter2++)
			{
				tree_info* tmp = iter2->second;
				while (tmp)
				{
					lm_node_num++; // this is the reverse index unit number, as well as the number of nodes in LM trees.
					tmp = tmp->next;
				}
			}
			lm_node_memory += iter->second->info_map.size() * 48; // each KV of the map has size 24
		}
		lm_node_memory += lm_node_num * 24; // memory of the reverse index units (tree_info)
		lm_node_memory = (lm_node_memory / (1024 * 1024));
		cout << "node number in LM tree: " << lm_node_num << ", memory: " << lm_node_memory << endl;
		fout << "node number in LM tree: " << lm_node_num << ", memory: " << lm_node_memory << endl;

		// similar as above, but in normal trees.
		unsigned int tree_node_num = 0;
		tree_node_memory += m_size + v2t_index.size() * 40;
		for (map<unsigned int, tree_info_index*>::iterator iter = v2t_index.begin(); iter != v2t_index.end(); iter++)
		{
			tree_node_memory += um_size + m_size;
			tree_node_memory += iter->second->tree_index.bucket_count() * 8 + iter->second->tree_index.size() * 24;
			for (unordered_map<unsigned int, tree_info*>::iterator iter2 = iter->second->tree_index.begin(); iter2 != iter->second->tree_index.end(); iter2++)
			{
				tree_info* tmp = iter2->second;
				while (tmp)
				{
					tree_node_num++;
					tmp = tmp->next;
				}
			}
			tree_node_memory += iter->second->info_map.size() * 40;
		}
		tree_node_memory += tree_node_num * 24;
		tree_node_memory = (tree_node_memory / (1024 * 1024));
		cout << "node number in normal tree: " << tree_node_num << ", memory: " << tree_node_memory << endl;
		fout << "node number in normal tree: " << tree_node_num << ", memory: " << tree_node_memory << endl;

		unsigned int DF_node_num = 0;
		DF_node_memory += m_size + v2d_index.size() * 40;
		for (map<unsigned int, tree_info_index*>::iterator iter = v2d_index.begin(); iter != v2d_index.end(); iter++)
		{
			DF_node_memory += um_size + m_size;
			DF_node_memory += iter->second->tree_index.bucket_count() * 8 + iter->second->tree_index.size() * 24;
			for (unordered_map<unsigned int, tree_info*>::iterator iter2 = iter->second->tree_index.begin(); iter2 != iter->second->tree_index.end(); iter2++)
			{
				tree_info* tmp = iter2->second;
				while (tmp)
				{
					DF_node_num++;
					tmp = tmp->next;
				}
			}
			DF_node_memory += iter->second->info_map.size() * 40;
		}
		DF_node_memory += DF_node_num * 24;
		DF_node_memory = (DF_node_memory / (1024 * 1024));
		cout << "node number in dependency tree: " << DF_node_num << ", memory: " << DF_node_memory << endl;
		cout << "total memory besides result set: " << (tree_memory + global_lm_memory + lm_set_memory + time_info_memory + lm_node_memory + tree_node_memory + DF_tree_memory + DF_node_memory) << endl;
		fout << "node number in dependency tree: " << DF_node_num << ", memory: " << DF_node_memory << endl;
		fout << "total memory besides result set: " << (tree_memory + global_lm_memory + lm_set_memory + time_info_memory + lm_node_memory + tree_node_memory+DF_tree_memory + DF_node_memory) << endl;
		cout << endl;
		fout << endl;
	}

	void results_update(int time) // this function deletes out dated results with timestamp smaller than given time
	{
		if (time <= 0)
			return;
		for (unordered_map<unsigned long long, unsigned int>::iterator iter = result_pairs.begin(); iter != result_pairs.end();)
		{
			if (iter->second < time) {
				iter = result_pairs.erase(iter);
			}
			else
				iter++;
		}
		shrink(result_pairs);
	}

	void erase_tree_node(RPQ_tree* tree_pt, tree_node* child, unordered_set<unsigned long long>& expired_de)  // this function deletes subtree rooted at the given node (child) in a normal tree (tree_pt)
	{
		queue<tree_node*> q;
		q.push(child);
		tree_pt->separate_node(child); // 'child' is disconnected with its parent,other nodes donot need to call this function, as there parents and brothers are all deleted;
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			if (tmp->lm) {
				expired_de.insert(merge_long_long(tmp->node_ID, tmp->state));
				tree_pt->timed_landmarks.erase(merge_long_long(tmp->node_ID, tmp->state));
			}
			for (tree_node* cur = tmp->child; cur; cur = cur->brother)
				q.push(cur);
			tree_pt->remove_node(tmp);
			delete_index(tmp->node_ID, tmp->state, tree_pt->root->node_ID);
			delete tmp;
		}
	}

	void erase_df_tree_node(RPQ_tree* tree_pt, tree_node* child)  // this function deletes subtree rooted at the given node (child) in a normal tree (tree_pt)
	{
		queue<tree_node*> q;
		q.push(child);
		tree_pt->separate_node(child); // 'child' is disconnected with its parent,other nodes donot need to call this function, as there parents and brothers are all deleted;
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			for (tree_node* cur = tmp->child; cur; cur = cur->brother)
				q.push(cur);
			tree_pt->remove_node(tmp);
			delete_df_index(tmp->node_ID, tmp->state, tree_pt->root->node_ID);
			delete tmp;
		}
	}

	void erase_lm_tree_node(RPQ_tree* tree_pt, tree_node* child, unordered_set<unsigned long long>& expired_de) // this function deletes subtree rooted at the given node (child) in an LM tree (tree_pt), different from above,
		// we need to record the deleted nodes with a vectore deleted, we will use these nodes in a backward search later to delete time info map in precursors of this LM tree in the dependency graph.
	{
		queue<tree_node*> q;
		q.push(child);
		tree_pt->separate_node(child); // 'child' is disconnected with its parent,other nodes donot need to call this function, as there parents and brothers are all deleted;
		while (!q.empty())
		{
			tree_node* tmp = q.front();
			q.pop();
			if (tmp->lm) {
				expired_de.insert(merge_long_long(tmp->node_ID, tmp->state));
				tree_pt->timed_landmarks.erase(merge_long_long(tmp->node_ID, tmp->state));
			}
			for (tree_node* cur = tmp->child; cur; cur = cur->brother)
				q.push(cur);
			tree_pt->remove_node(tmp);
			delete_lm_index(tmp->node_ID, tmp->state, tree_pt->root->node_ID, tree_pt->root->state);
			delete tmp;
		}
	}

	void expire_per_lm_tree(unsigned int v, unsigned int state, RPQ_tree* tree_pt, unsigned int expired_time, unordered_set<unsigned long long>& expired_de) // carry out expiration in an LM tree tree_pt given a possibly expired node (v, state) and tail of sliding window expired_time. 
	{
		if (tree_pt->node_map.find(state) != tree_pt->node_map.end())
		{
			if (tree_pt->node_map[state]->index.find(v) != tree_pt->node_map[state]->index.end()) {
				tree_node* dst_pt = tree_pt->node_map[state]->index[v];
				if (dst_pt->timestamp < expired_time) { // if this node indeex expireds, we need to erase its subtree and carry out expire_backtrack
					erase_lm_tree_node(tree_pt, dst_pt, expired_de);
				}
			}
		}
	}

	void expire_per_tree(unsigned int v, unsigned int state, RPQ_tree* tree_pt, unsigned int expired_time, unordered_set<unsigned long long>& expired_de) // expire in normal tree, we only need to delte the nodes in the subtree.
	{
		if (tree_pt->node_map.find(state) != tree_pt->node_map.end())
		{
			if (tree_pt->node_map[state]->index.find(v) != tree_pt->node_map[state]->index.end()) {
				tree_node* dst_pt = tree_pt->node_map[state]->index[v];
				if (dst_pt->timestamp < expired_time)
					erase_tree_node(tree_pt, dst_pt, expired_de);
			}

		}
	}

	void expire_per_df_tree(unsigned int v, unsigned int state, RPQ_tree* tree_pt, unsigned int expired_time) // expire in normal tree, we only need to delte the nodes in the subtree.
	{
		if (tree_pt->node_map.find(state) != tree_pt->node_map.end())
		{
			if (tree_pt->node_map[state]->index.find(v) != tree_pt->node_map[state]->index.end()) {
				tree_node* dst_pt = tree_pt->node_map[state]->index[v];
				if (dst_pt->timestamp < expired_time)
					erase_df_tree_node(tree_pt, dst_pt);
			}

		}
	}

	void expire(int current_time) //given current time, carry out an expiration in the forest.
	{
		int expire_time = current_time - g->window_size;
		results_update(expire_time); // delete expired results.
		vector<edge_info> deleted_edges;
		g->expire(current_time, deleted_edges); // delete expired edges in the graph
		unordered_set<unsigned long long> visited_pair;
		unordered_set<unsigned long long> visited_de;
		for (int i = 0; i < deleted_edges.size(); i++)
		{
			unsigned int dst = deleted_edges[i].d;
			unsigned int label = deleted_edges[i].label;
			vector<pair<int, int>> vec;
			aut->get_possible_state(label, vec); // dst node of the expired edge may be root of expired subtrees, get all the possible dst states/
			for (int j = 0; j < vec.size(); j++) {
				int dst_state = vec[j].second;
				if (dst_state == -1)
					continue;
				if (visited_pair.find(merge_long_long(dst, dst_state)) != visited_pair.end()) // some dst nodes may be checked before, and need not to be checked again.
					continue;
				visited_pair.insert(merge_long_long(dst, dst_state));
				unordered_set<unsigned long long> expired_de;
				map<unsigned int, tree_info_index*>::iterator iter = v2t_index.find(dst_state);
				if (iter != v2t_index.end())
				{
					unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter->second->tree_index.find(dst);
					if (tree_iter != iter->second->tree_index.end())
					{
						vector<RPQ_tree*> tree_to_delete;
						tree_info* tmp = tree_iter->second;
						while (tmp)
						{
							tree_to_delete.push_back(tmp->tree); // we first record the tree list and then check them one by one, as the deletion may change the tree list. 
							tmp = tmp->next;
						}
						for (int k = 0; k < tree_to_delete.size(); k++)
						{
							expire_per_tree(dst, dst_state, tree_to_delete[k], expire_time, expired_de);
							if (tree_to_delete[k]->root->child == NULL)
							{
								delete_index(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state, tree_to_delete[k]->root->node_ID);
								forests.erase(merge_long_long(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state));
								delete tree_to_delete[k];
							}
						}
						shrink(forests);
						tree_to_delete.clear();
					}
				}
				//expire in LM trees.
				map<unsigned int, lm_info_index*>::iterator iter2 = v2l_index.find(dst_state);
				if (iter2 != v2l_index.end())
				{
					unordered_map<unsigned int, tree_info*>::iterator tree_iter = iter2->second->tree_index.find(dst);
					if (tree_iter != iter2->second->tree_index.end())
					{
						vector<RPQ_tree*> tree_to_delete;
						tree_info* tmp = tree_iter->second;
						while (tmp)
						{
							tree_to_delete.push_back(tmp->tree);
							tmp = tmp->next;
						}
						for (int k = 0; k < tree_to_delete.size(); k++)
						{
							expire_per_lm_tree(dst, dst_state, tree_to_delete[k], expire_time, expired_de);
							if (tree_to_delete[k]->root->child == NULL)
							{
								delete_lm_index(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state, tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state);
								forests.erase(merge_long_long(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state));
								if (landmarks.find(merge_long_long(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state)) != landmarks.end()) {
									landmarks.erase(merge_long_long(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state));
									recover_subtree(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state, NULL);
									recover_subtree_lm(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state, NULL);
									modify_DF_lm_retire(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state);
								}

								delete tree_to_delete[k];
							}
						}
						shrink(forests);
						tree_to_delete.clear();
					}
				}
				for (unordered_set<unsigned long long>::iterator iter = expired_de.begin(); iter != expired_de.end(); iter++)
				{
					if (visited_de.find(*iter) != visited_de.end())
						continue;
					visited_de.insert(*iter);
					unsigned int lm_id = (*iter >> 32);
					unsigned int lm_state = (*iter & 0xFFFFFFFF);
					if (v2d_index.find(lm_state) != v2d_index.end())
					{
						unordered_map<unsigned int, tree_info*>::iterator tree_iter = v2d_index[lm_state]->tree_index.find(lm_id);
						if (tree_iter != v2d_index[lm_state]->tree_index.end())
						{
							vector<RPQ_tree*> tree_to_delete;
							tree_info* tmp = tree_iter->second;
							while (tmp)
							{
								tree_to_delete.push_back(tmp->tree);
								tmp = tmp->next;
							}
							for (int k = 0; k < tree_to_delete.size(); k++)
							{
								expire_per_df_tree(lm_id, lm_state, tree_to_delete[k], expire_time);
								if (tree_to_delete[k]->root->child == NULL)
								{
									delete_df_index(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state, tree_to_delete[k]->root->node_ID);
									DF_forest.erase(merge_long_long(tree_to_delete[k]->root->node_ID, tree_to_delete[k]->root->state));
									delete tree_to_delete[k];
								}
							}
							shrink(DF_forest);
							tree_to_delete.clear();

						}
					}
				}
			}
		}

	}


};
